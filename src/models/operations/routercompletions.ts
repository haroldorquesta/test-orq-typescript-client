/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
 */
export type Prompt = string | Array<any>;

/**
 * Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
 */
export type Stop = string | Array<string>;

/**
 * A request body that follows the official OpenAI schema
 */
export type RouterCompletionsRequestBody = {
  /**
   * ID of the model to use
   */
  model: string;
  /**
   * The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
   */
  prompt: string | Array<any>;
  /**
   * Echo back the prompt in addition to the completion
   */
  echo?: boolean | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * The maximum number of tokens that can be generated in the completion.
   */
  maxTokens?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Whether to stream back partial progress.
   */
  stream?: boolean | null | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
   */
  topP?: number | null | undefined;
  /**
   * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.
   */
  user?: string | undefined;
};

/**
 * The reason the model stopped generating tokens.
 */
export const FinishReason = {
  Stop: "stop",
  Length: "length",
  ContentFilter: "content_filter",
  ToolCalls: "tool_calls",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type FinishReason = ClosedEnum<typeof FinishReason>;

export type RouterCompletionsChoices = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: FinishReason;
  /**
   * The index of the choice in the list of choices.
   */
  index: number;
  text: string;
};

/**
 * Usage statistics for the completion request.
 */
export type RouterCompletionsUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
};

/**
 * A response body that follows the official OpenAI schema
 */
export type RouterCompletionsResponseBody = {
  /**
   * A unique identifier for the completion.
   */
  id: string;
  /**
   * The list of completion choices the model generated for the input prompt.
   */
  choices: Array<RouterCompletionsChoices>;
  /**
   * The Unix timestamp (in seconds) of when the chat completion was created.
   */
  created: number;
  /**
   * The model used for the chat completion.
   */
  model: string;
  /**
   * This fingerprint represents the backend configuration that the model runs with.
   */
  systemFingerprint: string;
  /**
   * The object type
   */
  object: string;
  /**
   * Usage statistics for the completion request.
   */
  usage: RouterCompletionsUsage;
};

/** @internal */
export const Prompt$inboundSchema: z.ZodType<Prompt, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.array(z.any())]);

/** @internal */
export type Prompt$Outbound = string | Array<any>;

/** @internal */
export const Prompt$outboundSchema: z.ZodType<
  Prompt$Outbound,
  z.ZodTypeDef,
  Prompt
> = z.union([z.string(), z.array(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Prompt$ {
  /** @deprecated use `Prompt$inboundSchema` instead. */
  export const inboundSchema = Prompt$inboundSchema;
  /** @deprecated use `Prompt$outboundSchema` instead. */
  export const outboundSchema = Prompt$outboundSchema;
  /** @deprecated use `Prompt$Outbound` instead. */
  export type Outbound = Prompt$Outbound;
}

export function promptToJSON(prompt: Prompt): string {
  return JSON.stringify(Prompt$outboundSchema.parse(prompt));
}

export function promptFromJSON(
  jsonString: string,
): SafeParseResult<Prompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Prompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Prompt' from JSON`,
  );
}

/** @internal */
export const Stop$inboundSchema: z.ZodType<Stop, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.array(z.string())]);

/** @internal */
export type Stop$Outbound = string | Array<string>;

/** @internal */
export const Stop$outboundSchema: z.ZodType<Stop$Outbound, z.ZodTypeDef, Stop> =
  z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Stop$ {
  /** @deprecated use `Stop$inboundSchema` instead. */
  export const inboundSchema = Stop$inboundSchema;
  /** @deprecated use `Stop$outboundSchema` instead. */
  export const outboundSchema = Stop$outboundSchema;
  /** @deprecated use `Stop$Outbound` instead. */
  export type Outbound = Stop$Outbound;
}

export function stopToJSON(stop: Stop): string {
  return JSON.stringify(Stop$outboundSchema.parse(stop));
}

export function stopFromJSON(
  jsonString: string,
): SafeParseResult<Stop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stop' from JSON`,
  );
}

/** @internal */
export const RouterCompletionsRequestBody$inboundSchema: z.ZodType<
  RouterCompletionsRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
  prompt: z.union([z.string(), z.array(z.any())]),
  echo: z.nullable(z.boolean().default(false)),
  frequency_penalty: z.nullable(z.number().default(0)),
  max_tokens: z.nullable(z.number().default(16)),
  presence_penalty: z.nullable(z.number().default(0)),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream: z.nullable(z.boolean().default(false)),
  temperature: z.nullable(z.number().default(1)),
  top_p: z.nullable(z.number().default(1)),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "presence_penalty": "presencePenalty",
    "top_p": "topP",
  });
});

/** @internal */
export type RouterCompletionsRequestBody$Outbound = {
  model: string;
  prompt: string | Array<any>;
  echo: boolean | null;
  frequency_penalty: number | null;
  max_tokens: number | null;
  presence_penalty: number | null;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream: boolean | null;
  temperature: number | null;
  top_p: number | null;
  user?: string | undefined;
};

/** @internal */
export const RouterCompletionsRequestBody$outboundSchema: z.ZodType<
  RouterCompletionsRequestBody$Outbound,
  z.ZodTypeDef,
  RouterCompletionsRequestBody
> = z.object({
  model: z.string(),
  prompt: z.union([z.string(), z.array(z.any())]),
  echo: z.nullable(z.boolean().default(false)),
  frequencyPenalty: z.nullable(z.number().default(0)),
  maxTokens: z.nullable(z.number().default(16)),
  presencePenalty: z.nullable(z.number().default(0)),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream: z.nullable(z.boolean().default(false)),
  temperature: z.nullable(z.number().default(1)),
  topP: z.nullable(z.number().default(1)),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    presencePenalty: "presence_penalty",
    topP: "top_p",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RouterCompletionsRequestBody$ {
  /** @deprecated use `RouterCompletionsRequestBody$inboundSchema` instead. */
  export const inboundSchema = RouterCompletionsRequestBody$inboundSchema;
  /** @deprecated use `RouterCompletionsRequestBody$outboundSchema` instead. */
  export const outboundSchema = RouterCompletionsRequestBody$outboundSchema;
  /** @deprecated use `RouterCompletionsRequestBody$Outbound` instead. */
  export type Outbound = RouterCompletionsRequestBody$Outbound;
}

export function routerCompletionsRequestBodyToJSON(
  routerCompletionsRequestBody: RouterCompletionsRequestBody,
): string {
  return JSON.stringify(
    RouterCompletionsRequestBody$outboundSchema.parse(
      routerCompletionsRequestBody,
    ),
  );
}

export function routerCompletionsRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<RouterCompletionsRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RouterCompletionsRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RouterCompletionsRequestBody' from JSON`,
  );
}

/** @internal */
export const FinishReason$inboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  z.nativeEnum(FinishReason);

/** @internal */
export const FinishReason$outboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  FinishReason$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FinishReason$ {
  /** @deprecated use `FinishReason$inboundSchema` instead. */
  export const inboundSchema = FinishReason$inboundSchema;
  /** @deprecated use `FinishReason$outboundSchema` instead. */
  export const outboundSchema = FinishReason$outboundSchema;
}

/** @internal */
export const RouterCompletionsChoices$inboundSchema: z.ZodType<
  RouterCompletionsChoices,
  z.ZodTypeDef,
  unknown
> = z.object({
  finish_reason: FinishReason$inboundSchema,
  index: z.number(),
  text: z.string(),
}).transform((v) => {
  return remap$(v, {
    "finish_reason": "finishReason",
  });
});

/** @internal */
export type RouterCompletionsChoices$Outbound = {
  finish_reason: string;
  index: number;
  text: string;
};

/** @internal */
export const RouterCompletionsChoices$outboundSchema: z.ZodType<
  RouterCompletionsChoices$Outbound,
  z.ZodTypeDef,
  RouterCompletionsChoices
> = z.object({
  finishReason: FinishReason$outboundSchema,
  index: z.number(),
  text: z.string(),
}).transform((v) => {
  return remap$(v, {
    finishReason: "finish_reason",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RouterCompletionsChoices$ {
  /** @deprecated use `RouterCompletionsChoices$inboundSchema` instead. */
  export const inboundSchema = RouterCompletionsChoices$inboundSchema;
  /** @deprecated use `RouterCompletionsChoices$outboundSchema` instead. */
  export const outboundSchema = RouterCompletionsChoices$outboundSchema;
  /** @deprecated use `RouterCompletionsChoices$Outbound` instead. */
  export type Outbound = RouterCompletionsChoices$Outbound;
}

export function routerCompletionsChoicesToJSON(
  routerCompletionsChoices: RouterCompletionsChoices,
): string {
  return JSON.stringify(
    RouterCompletionsChoices$outboundSchema.parse(routerCompletionsChoices),
  );
}

export function routerCompletionsChoicesFromJSON(
  jsonString: string,
): SafeParseResult<RouterCompletionsChoices, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RouterCompletionsChoices$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RouterCompletionsChoices' from JSON`,
  );
}

/** @internal */
export const RouterCompletionsUsage$inboundSchema: z.ZodType<
  RouterCompletionsUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
  });
});

/** @internal */
export type RouterCompletionsUsage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
};

/** @internal */
export const RouterCompletionsUsage$outboundSchema: z.ZodType<
  RouterCompletionsUsage$Outbound,
  z.ZodTypeDef,
  RouterCompletionsUsage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RouterCompletionsUsage$ {
  /** @deprecated use `RouterCompletionsUsage$inboundSchema` instead. */
  export const inboundSchema = RouterCompletionsUsage$inboundSchema;
  /** @deprecated use `RouterCompletionsUsage$outboundSchema` instead. */
  export const outboundSchema = RouterCompletionsUsage$outboundSchema;
  /** @deprecated use `RouterCompletionsUsage$Outbound` instead. */
  export type Outbound = RouterCompletionsUsage$Outbound;
}

export function routerCompletionsUsageToJSON(
  routerCompletionsUsage: RouterCompletionsUsage,
): string {
  return JSON.stringify(
    RouterCompletionsUsage$outboundSchema.parse(routerCompletionsUsage),
  );
}

export function routerCompletionsUsageFromJSON(
  jsonString: string,
): SafeParseResult<RouterCompletionsUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RouterCompletionsUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RouterCompletionsUsage' from JSON`,
  );
}

/** @internal */
export const RouterCompletionsResponseBody$inboundSchema: z.ZodType<
  RouterCompletionsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  choices: z.array(z.lazy(() => RouterCompletionsChoices$inboundSchema)),
  created: z.number(),
  model: z.string(),
  system_fingerprint: z.string(),
  object: z.string(),
  usage: z.lazy(() => RouterCompletionsUsage$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "system_fingerprint": "systemFingerprint",
  });
});

/** @internal */
export type RouterCompletionsResponseBody$Outbound = {
  id: string;
  choices: Array<RouterCompletionsChoices$Outbound>;
  created: number;
  model: string;
  system_fingerprint: string;
  object: string;
  usage: RouterCompletionsUsage$Outbound;
};

/** @internal */
export const RouterCompletionsResponseBody$outboundSchema: z.ZodType<
  RouterCompletionsResponseBody$Outbound,
  z.ZodTypeDef,
  RouterCompletionsResponseBody
> = z.object({
  id: z.string(),
  choices: z.array(z.lazy(() => RouterCompletionsChoices$outboundSchema)),
  created: z.number(),
  model: z.string(),
  systemFingerprint: z.string(),
  object: z.string(),
  usage: z.lazy(() => RouterCompletionsUsage$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    systemFingerprint: "system_fingerprint",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RouterCompletionsResponseBody$ {
  /** @deprecated use `RouterCompletionsResponseBody$inboundSchema` instead. */
  export const inboundSchema = RouterCompletionsResponseBody$inboundSchema;
  /** @deprecated use `RouterCompletionsResponseBody$outboundSchema` instead. */
  export const outboundSchema = RouterCompletionsResponseBody$outboundSchema;
  /** @deprecated use `RouterCompletionsResponseBody$Outbound` instead. */
  export type Outbound = RouterCompletionsResponseBody$Outbound;
}

export function routerCompletionsResponseBodyToJSON(
  routerCompletionsResponseBody: RouterCompletionsResponseBody,
): string {
  return JSON.stringify(
    RouterCompletionsResponseBody$outboundSchema.parse(
      routerCompletionsResponseBody,
    ),
  );
}

export function routerCompletionsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RouterCompletionsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RouterCompletionsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RouterCompletionsResponseBody' from JSON`,
  );
}
